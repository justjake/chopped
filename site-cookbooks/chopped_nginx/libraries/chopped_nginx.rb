require 'pry'
require 'pathname'
require_relative './chopped_nginx_providers.rb'

module Chopped
  module Nginx
    class Helper
      attr_reader :node
      def initialize(node)
        @node = node
      end

      def home
        @home ||= Pathname.new(node.chopped.nginx.nginx_home)
      end

      def http_d
        home.join('http.conf.d')
      end

      def bare_d
        home.join('bare.conf.d')
      end

      def conf
        home.join('nginx.conf')
      end

      # returns the name and path of a base chopped_nginx_config_file resource
      def bare_resource(resource)
        inner_name = "bare_#{resource.name}"
        inner_path = bare_d.join("#{resource.name}.conf").to_s
        return inner_name, inner_path
      end

      def http_resource(resource)
        inner_name = "http_#{resource.name}"
        inner_path = http_d.join("#{resource.name}.conf").to_s
        return inner_name, inner_path
      end
    end

    INDENT = '  '
    NEWLINE = "\n"

    def self.indent(ast, level = 0)
      final_lines = []
      ast.each do |item|
        if item.is_a? Enumerable
          final_lines.concat(indent(item, level + 1))
        else
          final_lines << INDENT * level + item.to_s
        end
      end
      final_lines
    end

    # meat and potatoes.
    # generate an nginx config file from a ruby data structure made out of
    # hashes, arrays, and strings
    def self.generate(tree)
      array = tree._render
      lines = indent(array, 0)
      lines.join(NEWLINE) + NEWLINE
    end

    def self.config(&block)
      cfg = AST::Config.new(&block)
      cfg.children.unshift(AST::Comment.new('this config generated by Chef. Editing by hand a bad idea'))
      generate(cfg)
    end

    module AST
      # TODO: somehow parse NGINX docs to validate chef configs
      module DSL
        # load a list of nginx directives that this module should support
        def self.load_support(text_file_path)
          lines = Pathname.new(text_file_path).read.split("\n")
          lines.each do |line|
            directive = line.split(/\s+/).first
            support_directive(directive)
          end
        end

        def self.support_directive(meth)
          meth = meth.to_sym
          define_method(meth) do |*args, &block|
            if !block.nil?
              total = [meth].concat(args)
              self._block(*total, &block)
            else
              self._prop(meth, *args)
            end
          end
        end

        # allows both styles of dsl:
        # foo do |f|
        #   f.a :hello
        #   f.b :world
        # end
        #
        # and
        # foo do
        #   a :hello
        #   b :world
        # end
        def intelligent_eval(block)
          if block.arity > 0
            block.call(self)
          else
            scope = ::Chopped::CombinedScope.new(self)
            scope.evaluate(block)
          end
        end

        def _push(item)
          children.push(item)
        end

        def _render
          # this flatten(1) is needed to keep block titles from over-indenting
          children.map { |c| c._render }.flatten(1)
        end

        def _block(*title, &dsl_block)
          blk = Block.new(title, [], &dsl_block)
          _push(blk)
        end

        def _prop(title, *values)
          _push(Directive.new(title, values))
        end

        def comment(text)
          _push(Comment.new(text))
        end

        ############################
        # SCIENCE HAS GONE TOO FAR #
        ############################
        # def method_missing(meth, *args, &block)
        #   # ban :node
        #   if meth.to_s == 'node'
        #     raise NoMethodError.new('node is banned', meth, args)
        #   end

        #   # what
        #   if block_given?
        #     # the
        #     total = [meth].concat(args)
        #     # fuck
        #     _block(*total, &block)
        #     # have
        #   else
        #     # I
        #     _prop(meth, *args)
        #     # done?
        #   end
        # end

        def to_s
          Chopped::Nginx.generate(self)
        end
      end # end DSL

      class Config
        include DSL
        attr_reader :children

        def initialize(&block)
          @children = []

          if block_given?
            intelligent_eval(block)
          end
        end
      end # end Config

      class Block < Struct.new('Block', :title, :children)
        include DSL

        def initialize(title, children = [], &block)
          super(title, children)
          if block_given?
            intelligent_eval(block)
          end
        end

        def _render
          title_s = (title + ['{']).join(' ')
          children_array = super
          close_s = '}'

          [title_s, children_array, close_s]
        end
      end # end Block

      Directive = Struct.new('Directive', :title, :values) do
        def _render
          ([title] + values).join(' ') + ';'
        end
      end # end Directive

      Comment = Struct.new('Comment', :text) do
        def _render
          '# ' + text
        end
      end # end Comment
    end # end module
  end
end

directives_path = Pathname.new(__FILE__).dirname.join('nginx_directives.txt').to_s
Chopped::Nginx::AST::DSL.load_support(directives_path)

def test
  b = Chopped::Nginx.config do
    user 'foo bar'
    worker_processes 5

    server :dog do
      root :jackie
      satisfy 55
    end

    server :cat do
      root :rat
      satisfy :face
      queue '"what"'
    end
  end
end

print test
